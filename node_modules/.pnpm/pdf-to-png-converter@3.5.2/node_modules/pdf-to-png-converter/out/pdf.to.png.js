"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pdfToPng = pdfToPng;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const const_1 = require("./const");
const props_to_pdf_doc_init_params_1 = require("./props.to.pdf.doc.init.params");
function pdfToPng(pdfFilePathOrBuffer, props) {
    return __awaiter(this, void 0, void 0, function* () {
        const isBuffer = Buffer.isBuffer(pdfFilePathOrBuffer);
        const pdfFileBuffer = isBuffer
            ? pdfFilePathOrBuffer
            : yield node_fs_1.promises.readFile(pdfFilePathOrBuffer);
        const pdfDocInitParams = Object.assign(Object.assign({}, (0, props_to_pdf_doc_init_params_1.propsToPdfDocInitParams)(props)), { data: new Uint8Array(pdfFileBuffer) });
        const { getDocument } = yield import('pdfjs-dist/legacy/build/pdf.mjs');
        const pdfDocument = yield getDocument(pdfDocInitParams).promise;
        const canvasFactory = pdfDocument.canvasFactory;
        const targetedPageNumbers = (props === null || props === void 0 ? void 0 : props.pagesToProcess) !== undefined
            ? props.pagesToProcess
            : Array.from({ length: pdfDocument.numPages }, (_, index) => index + 1);
        if ((props === null || props === void 0 ? void 0 : props.strictPagesToProcess) && targetedPageNumbers.some((pageNum) => pageNum < 1)) {
            throw new Error('Invalid pages requested, page number must be >= 1');
        }
        if ((props === null || props === void 0 ? void 0 : props.strictPagesToProcess) && targetedPageNumbers.some((pageNum) => pageNum > pdfDocument.numPages)) {
            throw new Error('Invalid pages requested, page number must be <= total pages');
        }
        if (props === null || props === void 0 ? void 0 : props.outputFolder) {
            yield node_fs_1.promises.mkdir(props.outputFolder, { recursive: true });
        }
        const pngPagesOutput = [];
        for (const pageNumber of targetedPageNumbers) {
            if (pageNumber > pdfDocument.numPages || pageNumber < 1) {
                continue;
            }
            const page = yield pdfDocument.getPage(pageNumber);
            const viewport = page.getViewport({
                scale: (props === null || props === void 0 ? void 0 : props.viewportScale) !== undefined ? props.viewportScale : const_1.PDF_TO_PNG_OPTIONS_DEFAULTS.viewportScale,
            });
            const { canvas, context } = canvasFactory.create(viewport.width, viewport.height);
            const name = (props === null || props === void 0 ? void 0 : props.outputFileMaskFunc)
                ? props.outputFileMaskFunc(pageNumber)
                : `${isBuffer
                    ? const_1.PDF_TO_PNG_OPTIONS_DEFAULTS.outputFileMask
                    : (0, node_path_1.parse)(pdfFilePathOrBuffer).name}_page_${pageNumber}.png`;
            yield page.render({ canvasContext: context, viewport }).promise;
            const pngPageOutput = {
                pageNumber,
                name,
                content: canvas.toBuffer(),
                path: '',
                width: viewport.width,
                height: viewport.height,
            };
            if (props === null || props === void 0 ? void 0 : props.outputFolder) {
                pngPageOutput.path = (0, node_path_1.resolve)(props.outputFolder, pngPageOutput.name);
                yield node_fs_1.promises.writeFile(pngPageOutput.path, pngPageOutput.content);
            }
            pngPagesOutput.push(pngPageOutput);
            page.cleanup();
        }
        yield pdfDocument.cleanup();
        return pngPagesOutput;
    });
}
